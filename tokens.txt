inline real clamp([2]real min, real max, );
real clamp_01([0]real x);
real lerp([2]real b, real t, );
static inline Vec2 operator([0]Vec2 a);
static inline Vec2 operator([1]Vec2 b, );
static inline Vec2 operator([1]Vec2 b, );
static inline Vec2 operator*([1]real s, );
static inline Vec2 operator([1]Vec2 a, );
static inline Vec2 operator([1]real s, );
static inline Vec2 operator*([1]Vec2 a, );
static inline Vec2 operator*([1]Vec2 b, );
static inline Vec2 operator([1]Vec2 b, );
static inline Vec2 operator([1]Vec2 b, );
static inline Vec2 operator*([1]real b, );
static inline Vec3 v3([2]real y, real z, );
static inline Vec3 v3([1]real z, );
static inline Vec3 v3([0]Vec2 a);
static inline Vec3 operator([0]Vec3 a);
static inline Vec3 operator([1]Vec3 b, );
static inline Vec3 operator([1]Vec3 b, );
static inline Vec3 operator*([1]real s, );
static inline Vec3 operator([1]Vec3 a, );
static inline Vec3 operator([1]real s, );
static inline Vec3 operator*([1]Vec3 a, );
static inline Vec3 operator*([1]Vec3 b, );
static inline Vec3 operator([1]Vec3 b, );
static inline Vec3 operator([1]Vec3 b, );
static inline Vec3 operator*([1]real b, );
static inline Vec4 operator*([1]Vec4 b, );
static inline Vec4 operator*([1]real b, );
static inline Vec4 operator*([1]Vec4 a, );
static inline Vec4 operator([1]real b, );
static inline Vec4 operator*([1]real b, );
static inline Vec4 operator*([1]Vec4 b, );
static inline Vec4 v4([3]real y, real z, real w, );
Vec4 hex_to_v4([0]uint32 hex);
static inline Vec2 v2([1]real y, );
static inline Vec2 v2([0]Vec3 v);
static inline Vec2 v2([0]Vec2i vi);
static inline Vec2i v2i([1]int32 y, );
inline Vec2 v2_perpendicular([0]Vec2 v);
inline real v2_dot([1]Vec2 b, );
inline real v2_cross([1]Vec2 b, );
inline Vec2 v2_from_angle([0]real normal);
inline real v2_to_angle([0]Vec2 v);
inline Vec2 v2_normalize([0]Vec2 v);
static inline bool operator([1]Rect2 b, );
static inline Rect2_Clip_Info rect2_clip([1]Rect2 clip, );
static inline Rect2i rect2i([3]int32 y, int32 w, int32 h, );
static inline bool aabb_intersect([1]AABB* b, );
static inline bool aabb_intersect([1]AABB b, );
static inline void aabb_overlap([2]AABB* b, Vec2* s, );
static inline AABB aabb([2]real hw, real hh, );
static inline AABB aabb([3]real y, real hw, real hh, );
static inline Rect2 rect2([3]real y, real w, real h, );
static inline Rect2 intrect_to_rect([0]Rect2i* ir);
static inline Rect2i rect_to_intrect([0]Rect2* ir);
static inline AABB rect_to_aabb([0]Rect2* r);
static inline AABB intrect_to_aabb([0]Rect2i* r);
static inline Rect2 aabb_to_rect([0]AABB* b);
static inline Rect2i aabb_to_intrect([0]AABB* b);
static inline isize modulus([1]isize b, );
exclude([0]end);
static inline isize mem_align_4([0]isize p);
void init_memory_arena([1]usize size, );
uint8* arena_push([1]isize size, );
void start_temp_arena([0]Memory_Arena* arena);
void end_temp_arena([0]Memory_Arena* arena);
void clear_arena([0]Memory_Arena* arena);
Memory_Arena* new_memory_arena([1]Memory_Arena* src, );
static inline uint64 _splitmix64([0]uint64* x);
static inline uint64 _rotate_left([1]int64 k, );
uint64 next_random_uint64([0]Random* r);
void init_random([1]uint64 seed, );
real64 next_random_double([0]Random* r);
real32 next_random_float([0]Random* r);
real next_random([0]Random* r);
real rand_range([2]real min, real max, );
int32 rand_range_int([2]real min, real max, );
real64 next_random_double([0]);
real32 next_random_float([0]);
real next_random([0]);
real rand_range([1]real max, );
int32 rand_range_int([1]real max, );
void game_set_scale([0]real scale);
void game_calc_mouse_pos([0]Vec2 offset);
void input_text_append_char([0]char c);
bool is_valid_filename_char([0]char c);
char replace_filename_char([1]char replace, );
isize replace_invalid_filename_chars([2]isize len, char replace, );
isize append_input_text([3]isize str_cap, isize str_len, isize insert_from_end =0),);
GenerateIntrosortForType([3]Sprite, _get_sprite_y_base, );
void init_group([2]isize sprites_capacity, Memory_Arena* arena, );
void init_renderer([5]isize group_count, isize group_size, char* vertex_source, char* frag_source, Memory_Arena* arena, );
Render_Group* render_group([1]isize index, );
void render_start([0]Render_Group* group);
bool render_has_clip_rect([0]Render_Group* group);
void render_set_clip_rect([4]real x, real y, real w, real h, );
void render_sort([1]isize offset, );
void render_add([1]Sprite* sprite, );
void render_add_unclipped([1]Sprite* sprite, );
void render_add([1]Sprite4* s4, );
void render_calculate_ortho_matrix([3]Vec4 screen, real nearplane, real farplane, );
void render_draw([3]Render_Group* group, Vec2 size, real scale, );
void render_set_current_group([0]isize index);
void render_start([0]);
bool render_has_clip_rect([0]);
void render_set_clip_rect([3]real y, real w, real h, );
void render_sort([0]isize offset);
void render_add([0]Sprite* sprite);
void render_add_unclipped([0]Sprite* sprite);
void render_add([0]Sprite4* s4);
void render_draw([1]real scale, );
GLuint ogl_add_texture([2]isize w, isize h, );
GLuint ogl_load_texture([2]isize* w_o, isize* h_o, );
Sprite create_box_primitive([2]Vec2 size, Vec4 color, );
void render_box_primitive([3]Vec2 pos, Vec2 size, Vec4 color, );
Sprite create_line_primitive([3]Vec2 end, Vec4 color, int32 thickness, );
void render_line_primitive([4]Vec2 start, Vec2 end, Vec4 color, int32 thickness, );
Sprite4 create_box_outline_primitive([3]Vec2 size, Vec4 color, int32 thickness, );
void render_box_outline_primitive([4]Vec2 center, Vec2 size, Vec4 color, int32 thickness, );
Sprite4 create_box_outline_primitive([3]Vec2 size, Vec4 color, int32 thickness, );
void render_box_outline_primitive([4]Vec2 center, Vec2 size, Vec4 color, int32 thickness, );
void render_box_primitive([2]Vec2 size, Vec4 color, );
void render_line_primitive([3]Vec2 end, Vec4 color, int32 thickness, );
void render_box_outline_primitive([3]Vec2 size, Vec4 color, int32 thickness, );
void render_box_outline_primitive([3]Vec2 size, Vec4 color, int32 thickness, );
void init_animation_frame([0]Animation_Frame* fr);
void init_animation([3]real fps, isize capacity, Memory_Arena* arena, );
Animation* make_animaiton_from_strip([3]real fps, Rect2 frame, isize count, );
void init_animated_sprite([2]isize capacity, Memory_Arena* arena, );
void animated_sprite_update([1]real timestep, );
isize add_animation([1]Animation* a, );
isize play_animation([1]isize anim_index, );
void init_spritefont([0]Spritefont* font);
static inline int32 dec_str_to_int([1]isize len, );
static inline bool _isnt_spritefont_separator([0]char c);
Rect2* parse_spritefont_rectangles([5]Memory_Arena* arena, int32 offsetx, int32 offsety, int32* w, int32* h, );
void load_spritefont([2]char* file_path_in, Vec2i offset, );
Spritefont* load_spritefont([1]Vec2i offset, );
Vec2 spritefont_size_text([2]char* text, isize len, );
Vec2 spritefont_size_text([1]char* text, );
void spritefont_render_text([7]char* text, isize len, Vec2 position, int32 max_width = -1,,Sprite_Anchor anchor Anchor_Top_Left = Anchor_Top_Left,,real scale f = 1.0f,,Vec2* region NULL = NULL),);
void spritefont_render_text_ex([7]char* text, isize len, Vec2 position, int32 max_width = -1,,Sprite_Anchor anchor Anchor_Top_Left = Anchor_Top_Left,,real scale f = 1.0f,,Vec2* region NULL = NULL),);
void spritefont_render_text([4]char* text, Vec2 position, Sprite_Anchor anchor Anchor_Top_Left = Anchor_Top_Left,,real scale f = 1.0f),);
void spritefont_render_text_background([4]char* text, Vec2 position, real scale, Vec4 background, );
void render_body_text([3]Vec2 position, bool background false =false,,real scale f = 1.0f),);
void render_title_text([1]Vec2 position, );
bool gui_query_mouse([1]Vec2 parent, );
bool gui_add_button([2]char* text, Vec2 minimum_size, );
bool gui_add_button([1]char* text, );
bool gui_add_checkbox([2]char* text, bool* value, );
void gui_add_slider([8]Vec2 size, char* label, real min, real max, int precision, real* in_value, bool* active, bool show_bounds false = false),);
void init_text_input_handle([3]char* buf, isize capacity, isize length, );
void init_text_input_handle([2]real width, Memory_Arena* arena, );
void gui_add_text_input([3]Vec2 position, Vec2 size, char* default_text NULL =NULL),);
void init_tile_state([1]isize id, );
usize hash_str([0]const char* str);
void init_game_registry([1]Memory_Arena* arena, );
return_type* lookup_func_name([0]const char* name);
_game_registry__ void sort_func_name([0]);
void finalize_game_registry([0]);
Tile_Info* add_tile_info([5]real movement_modifier, real friction, Rect2 texture, bool solid, char* break_to_name, );
void register_all_rituals_tile_info([0]);
Item_Info* add_item_type([2]int32 max_stack, Rect2 texture, );
void register_all_rituals_item_info([0]);
void register_everything_in_rituals([0]);
void init_item_stack([1]Item_Info* info, );
Item_Stack* new_item_stack([1]Memory_Arena* arena, );
void init_inventory([3]isize w, isize h, Memory_Arena* arena, );
bool inventory_add_item([1]Item_Stack** origin_slot, );
void render_inventory([1]Vec2 position, );
void init_tilemap([3]isize w, isize h, Memory_Arena* arena, );
void generate_tilemap([1]uint64 seed, );
Tile tilemap_get_at([2]isize x, isize y, );
Tile tilemap_get_at([1]Vec2 pos, );
Tile_State* tilemap_get_state_at([2]isize x, isize y, );
Tile_State* tilemap_get_state_at([1]Vec2 pos, );
bool tilemap_set_at([3]isize x, isize y, Tile value, );
bool tilemap_set_at([2]Vec2 pos, Tile value, );
void update_tile_state_at([2]isize x, isize y, );
void update_tile_state_at([1]Vec2 pos, );
void render_tilemap([1]Vec2 pos, );
isize render_tilemap([2]Vec2 pos, Rect2 area, );
GenerateIntrosortForType([3]Sim_Body, _body_get_min_x, );
void init_static_grid([3]Vec2i size, isize capacity, Memory_Arena* arena, );
Sim_Grid_Cell* get_next_grid_cell([0]Sim_Static_Grid* grid);
void build_static_grid([2]Sim_Body* bodies, isize count, );
Sim_Body* sim_get_next_static_body([0]Simulator* sim);
Sim_Body* sim_get_next_body([0]Simulator* sim);
void init_simulator([2]isize cap, Memory_Arena* arena, );
Sim_Body* sim_find_body([1]isize id, );
void sim_sort_bodies_on_id([0]Simulator* sim);
void sim_remove_body([1]isize body, );
void sim_remove_body([1]Sim_Body* body, );
Sim_Body* sim_query_aabb([1]AABB query, );
int32 _do_collide_bodies([3]Sim_Body* b, Simulator* sim, bool do_sweep, );
void _separate_bodies([4]Sim_Body* b, bool capture_contacts, int32 times, Simulator* sim, );
void sim_update([3]Tilemap* map, real dt, bool capture_contacts true = true),);
Tile_Info* _get_at([1]isize y, );
void generate_statics_for_tilemap([1]Tilemap* tilemap, );
Particle_Style copy_particle_style([2]Vec2 impulse_range, Vec2i time_range, );
Particle_Style make_particle_style([16]Vec2 size, Vec4 color, Vec4 shadow_color, Vec3 acl, Vec2 impulse_range, Vec2 angle_range, Vec2 angle_vel_range, Vec2 scale_range, Vec2i frame_range, int32 max_frames, int32 framerate, Vec2i time_range, bool time_scaling, real ground_restitution, Vec2 skid_on_bounce_range, real jitter_on_bounce_mag, );
void init_particle([8]Vec3 pos, Vec3 vel, real scale, real angle, real anglev, int32 frame, int32 time, int32 style_index, );
void init_emitter([2]isize max_particles, Memory_Arena* arena, );
void emitter_spawn([4]Vec3 pos, Vec2 angle_range, isize count, Particle_Style style, );
void emitter_render([2]Simulator* sim, real dt, );
GenerateIntrosortForType([3]Hitbox, _hitbox_get_x1, );
void init_world_area([1]Memory_Arena* arena, );
void init_entity([0]Entity* entity);
Entity* world_area_get_next_entity([0]World_Area* area);
Entity* world_area_find_entity([1]isize id, );
void world_area_sort_entities_on_id([0]World_Area* area);
void world_area_synchronize_entities_and_bodies([0]World_Area* area);
bool world_area_remove_entity([1]Entity* entity, );
void world_area_remove_entity_internal([1]isize id, );
void world_area_process_removed_entities([0]World_Area* area);
void world_area_build_hitboxes([0]World_Area* area);
void world_area_process_hitboxes([0]World_Area* area);
void init_world([4]isize width, isize height, usize seed, Memory_Arena* arena, );
void world_area_init_player([2]Vec2i tile_pos, bool move_player true =true),);
void world_area_deinit_player([1]bool move_player true =true),);
World_Area* world_load_area([2]isize id, Memory_Arena* arena, );
v