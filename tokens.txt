inline real clamp([3]real x, real min, real max);
real clamp_01([1]real x);
real lerp([3]real a, real b, real t);
static inline Vec2 operator([1]Vec2 a);
static inline Vec2 operator([2]Vec2 a, Vec2 b);
static inline Vec2 operator([2]Vec2 a, Vec2 b);
static inline Vec2 operator*([2]Vec2 a, real s);
static inline Vec2 operator([2]real s, Vec2 a);
static inline Vec2 operator([2]Vec2 a, real s);
static inline Vec2 operator*([2]real s, Vec2 a);
static inline Vec2 operator*([2]Vec2 a, Vec2 b);
static inline Vec2 operator([2]Vec2 a, Vec2 b);
static inline Vec2 operator([2]Vec2 a, Vec2 b);
static inline Vec2 operator*([2]Vec2 a, real b);
static inline Vec3 v3([3]real x, real y, real z);
static inline Vec3 v3([2]Vec2 a, real z);
static inline Vec3 v3([1]Vec2 a);
static inline Vec3 operator([1]Vec3 a);
static inline Vec3 operator([2]Vec3 a, Vec3 b);
static inline Vec3 operator([2]Vec3 a, Vec3 b);
static inline Vec3 operator*([2]Vec3 a, real s);
static inline Vec3 operator([2]real s, Vec3 a);
static inline Vec3 operator([2]Vec3 a, real s);
static inline Vec3 operator*([2]real s, Vec3 a);
static inline Vec3 operator*([2]Vec3 a, Vec3 b);
static inline Vec3 operator([2]Vec3 a, Vec3 b);
static inline Vec3 operator([2]Vec3 a, Vec3 b);
static inline Vec3 operator*([2]Vec3 a, real b);
static inline Vec4 operator*([2]Vec4 a, Vec4 b);
static inline Vec4 operator*([2]Vec4 a, real b);
static inline Vec4 operator*([2]real b, Vec4 a);
static inline Vec4 operator([2]Vec4 a, real b);
static inline Vec4 operator*([2]Vec4 a, real b);
static inline Vec4 operator*([2]Vec4 a, Vec4 b);
static inline Vec4 v4([4]real x, real y, real z, real w);
Vec4 hex_to_v4([1]uint32 hex);
static inline Vec2 v2([2]real x, real y);
static inline Vec2 v2([1]Vec3 v);
static inline Vec2 v2([1]Vec2i vi);
static inline Vec2i v2i([2]int32 x, int32 y);
inline Vec2 v2_perpendicular([1]Vec2 v);
inline real v2_dot([2]Vec2 a, Vec2 b);
inline real v2_cross([2]Vec2 a, Vec2 b);
inline Vec2 v2_from_angle([1]real normal);
inline real v2_to_angle([1]Vec2 v);
inline Vec2 v2_normalize([1]Vec2 v);
static inline bool operator([2]Rect2 a, Rect2 b);
static inline Rect2_Clip_Info rect2_clip([2]Rect2 r, Rect2 clip);
static inline Rect2i rect2i([4]int32 x, int32 y, int32 w, int32 h);
static inline bool aabb_intersect([2]AABB* a, AABB* b);
static inline bool aabb_intersect([2]AABB a, AABB b);
static inline void aabb_overlap([3]AABB* a, AABB* b, Vec2* s);
static inline AABB aabb([3]Vec2 c, real hw, real hh);
static inline AABB aabb([4]real x, real y, real hw, real hh);
static inline Rect2 rect2([4]real x, real y, real w, real h);
static inline Rect2 intrect_to_rect([1]Rect2i* ir);
static inline Rect2i rect_to_intrect([1]Rect2* ir);
static inline AABB rect_to_aabb([1]Rect2* r);
static inline AABB intrect_to_aabb([1]Rect2i* r);
static inline Rect2 aabb_to_rect([1]AABB* b);
static inline Rect2i aabb_to_intrect([1]AABB* b);
static inline isize modulus([2]isize a, isize b);
exclude([1]end);
static inline isize mem_align_4([1]isize p);
void init_memory_arena([2]Memory_Arena* arena, usize size);
uint8* arena_push([2]Memory_Arena* arena, isize size);
void start_temp_arena([1]Memory_Arena* arena);
void end_temp_arena([1]Memory_Arena* arena);
void clear_arena([1]Memory_Arena* arena);
Memory_Arena* new_memory_arena([2]usize size, Memory_Arena* src);
static inline uint64 _splitmix64([1]uint64* x);
static inline uint64 _rotate_left([2]const uint64 t, int64 k);
uint64 next_random_uint64([1]Random* r);
void init_random([2]Random* r, uint64 seed);
real64 next_random_double([1]Random* r);
real32 next_random_float([1]Random* r);
real next_random([1]Random* r);
real rand_range([3]Random* r, real min, real max);
int32 rand_range_int([3]Random* r, real min, real max);
real64 next_random_double([1]);
real32 next_random_float([1]);
real next_random([1]);
real rand_range([2]real min, real max);
int32 rand_range_int([2]real min, real max);
void game_set_scale([1]real scale);
void game_calc_mouse_pos([1]Vec2 offset);
void input_text_append_char([1]char c);
bool is_valid_filename_char([1]char c);
char replace_filename_char([2]char c, char replace);
isize replace_invalid_filename_chars([3]char* str, isize len, char replace);
isize append_input_text([4]char* str, isize str_cap, isize str_len, isize insert_from_end =0),);
GenerateIntrosortForType([4]sort_sprites_on_y_base, Sprite, _get_sprite_y_base);
void init_group([3]Render_Group* group, isize sprites_capacity, Memory_Arena* arena);
void init_renderer([6]OpenGL_Renderer* r, isize group_count, isize group_size, char* vertex_source, char* frag_source, Memory_Arena* arena);
Render_Group* render_group([2]OpenGL_Renderer* r, isize index);
void render_start([1]Render_Group* group);
bool render_has_clip_rect([1]Render_Group* group);
void render_set_clip_rect([5]Render_Group* group, real x, real y, real w, real h);
void render_sort([2]Render_Group* group, isize offset);
void render_add([2]Render_Group* group, Sprite* sprite);
void render_add_unclipped([2]Render_Group* group, Sprite* sprite);
void render_add([2]Render_Group* group, Sprite4* s4);
void render_calculate_ortho_matrix([4]real32* ortho, Vec4 screen, real nearplane, real farplane);
void render_draw([4]OpenGL_Renderer* r, Render_Group* group, Vec2 size, real scale);
void render_set_current_group([1]isize index);
void render_start([1]);
bool render_has_clip_rect([1]);
void render_set_clip_rect([4]real x, real y, real w, real h);
void render_sort([1]isize offset);
void render_add([1]Sprite* sprite);
void render_add_unclipped([1]Sprite* sprite);
void render_add([1]Sprite4* s4);
void render_draw([2]Vec2 size, real scale);
GLuint ogl_add_texture([3]uint8* data, isize w, isize h);
GLuint ogl_load_texture([3]char* filename, isize* w_o, isize* h_o);
Sprite create_box_primitive([3]Vec2 pos, Vec2 size, Vec4 color);
void render_box_primitive([4]Render_Group* group, Vec2 pos, Vec2 size, Vec4 color);
Sprite create_line_primitive([4]Vec2 start, Vec2 end, Vec4 color, int32 thickness);
void render_line_primitive([5]Render_Group* group, Vec2 start, Vec2 end, Vec4 color, int32 thickness);
Sprite4 create_box_outline_primitive([4]Vec2 center, Vec2 size, Vec4 color, int32 thickness);
void render_box_outline_primitive([5]Render_Group* group, Vec2 center, Vec2 size, Vec4 color, int32 thickness);
Sprite4 create_box_outline_primitive([4]Vec2 center, Vec2 size, Vec4 color, int32 thickness);
void render_box_outline_primitive([5]Render_Group* group, Vec2 center, Vec2 size, Vec4 color, int32 thickness);
void render_box_primitive([3]Vec2 pos, Vec2 size, Vec4 color);
void render_line_primitive([4]Vec2 start, Vec2 end, Vec4 color, int32 thickness);
void render_box_outline_primitive([4]Vec2 center, Vec2 size, Vec4 color, int32 thickness);
void render_box_outline_primitive([4]Vec2 center, Vec2 size, Vec4 color, int32 thickness);
void init_animation_frame([1]Animation_Frame* fr);
void init_animation([4]Animation* a, real fps, isize capacity, Memory_Arena* arena);
Animation* make_animaiton_from_strip([4]Memory_Arena* arena, real fps, Rect2 frame, isize count);
void init_animated_sprite([3]Animated_Sprite* s, isize capacity, Memory_Arena* arena);
void animated_sprite_update([2]Animated_Sprite* s, real timestep);
isize add_animation([2]Animated_Sprite* s, Animation* a);
isize play_animation([2]Animated_Sprite* s, isize anim_index);
void init_spritefont([1]Spritefont* font);
static inline int32 dec_str_to_int([2]char* str, isize len);
static inline bool _isnt_spritefont_separator([1]char c);
Rect2* parse_spritefont_rectangles([6]char* glyphs_file, Memory_Arena* arena, int32 offsetx, int32 offsety, int32* w, int32* h);
void load_spritefont([3]Spritefont* font, char* file_path_in, Vec2i offset);
Spritefont* load_spritefont([2]char* filepath, Vec2i offset);
Vec2 spritefont_size_text([3]Spritefont* font, char* text, isize len);
Vec2 spritefont_size_text([2]Spritefont* font, char* text);
void spritefont_render_text([8]Spritefont* font, char* text, isize len, Vec2 position, int32 max_width = -1,,Sprite_Anchor anchor Anchor_Top_Left = Anchor_Top_Left,,real scale f = 1.0f,,Vec2* region NULL = NULL),);
void spritefont_render_text_ex([8]Spritefont* font, char* text, isize len, Vec2 position, int32 max_width = -1,,Sprite_Anchor anchor Anchor_Top_Left = Anchor_Top_Left,,real scale f = 1.0f,,Vec2* region NULL = NULL),);
void spritefont_render_text([5]Spritefont* font, char* text, Vec2 position, Sprite_Anchor anchor Anchor_Top_Left = Anchor_Top_Left,,real scale f = 1.0f),);
void spritefont_render_text_background([5]Spritefont* font, char* text, Vec2 position, real scale, Vec4 background);
void render_body_text([4]char* text, Vec2 position, bool background false =false,,real scale f = 1.0f),);
void render_title_text([2]char* text, Vec2 position);
bool gui_query_mouse([2]Rect2 region, Vec2 parent);
bool gui_add_button([3]Vec2 position, char* text, Vec2 minimum_size);
bool gui_add_button([2]Vec2 position, char* text);
bool gui_add_checkbox([3]Vec2 position, char* text, bool* value);
void gui_add_slider([9]Vec2 position, Vec2 size, char* label, real min, real max, int precision, real* in_value, bool* active, bool show_bounds false = false),);
void init_text_input_handle([4]Gui_Text_Input_Handle* handle, char* buf, isize capacity, isize length);
void init_text_input_handle([3]Gui_Text_Input_Handle* handle, real width, Memory_Arena* arena);
void gui_add_text_input([4]Gui_Text_Input_Handle* handle, Vec2 position, Vec2 size, char* default_text NULL =NULL),);
void init_tile_state([2]Tile_State* state, isize id);
usize hash_str([1]const char* str);
void init_game_registry([2]Game_Registry* registry, Memory_Arena* arena);
return_type* lookup_func_name([1]const char* name);
_game_registry__ void sort_func_name([1]);
void finalize_game_registry([1]);
Tile_Info* add_tile_info([6]const char* name, real movement_modifier, real friction, Rect2 texture, bool solid, char* break_to_name);
void register_all_rituals_tile_info([1]);
Item_Info* add_item_type([3]const char* name, int32 max_stack, Rect2 texture);
void register_all_rituals_item_info([1]);
void register_everything_in_rituals([1]);
void init_item_stack([2]Item_Stack* stack, Item_Info* info);
Item_Stack* new_item_stack([2]Item_Info* info, Memory_Arena* arena);
void init_inventory([4]Inventory* inventory, isize w, isize h, Memory_Arena* arena);
bool inventory_add_item([2]Inventory* inventory, Item_Stack** origin_slot);
void render_inventory([2]Inventory* inventory, Vec2 position);
void init_tilemap([4]Tilemap* tilemap, isize w, isize h, Memory_Arena* arena);
void generate_tilemap([2]Tilemap* tilemap, uint64 seed);
Tile tilemap_get_at([3]Tilemap* tilemap, isize x, isize y);
Tile tilemap_get_at([2]Tilemap* tilemap, Vec2 pos);
Tile_State* tilemap_get_state_at([3]Tilemap* tilemap, isize x, isize y);
Tile_State* tilemap_get_state_at([2]Tilemap* tilemap, Vec2 pos);
bool tilemap_set_at([4]Tilemap* tilemap, isize x, isize y, Tile value);
bool tilemap_set_at([3]Tilemap* tilemap, Vec2 pos, Tile value);
void update_tile_state_at([3]Tilemap* map, isize x, isize y);
void update_tile_state_at([2]Tilemap* map, Vec2 pos);
void render_tilemap([2]Tilemap* tilemap, Vec2 pos);
isize render_tilemap([3]Tilemap* tilemap, Vec2 pos, Rect2 area);
GenerateIntrosortForType([4]body_sort_on_x, Sim_Body, _body_get_min_x);
void init_static_grid([4]Sim_Static_Grid* grid, Vec2i size, isize capacity, Memory_Arena* arena);
Sim_Grid_Cell* get_next_grid_cell([1]Sim_Static_Grid* grid);
void build_static_grid([3]Sim_Static_Grid* grid, Sim_Body* bodies, isize count);
Sim_Body* sim_get_next_static_body([1]Simulator* sim);
Sim_Body* sim_get_next_body([1]Simulator* sim);
void init_simulator([3]Simulator* sim, isize cap, Memory_Arena* arena);
Sim_Body* sim_find_body([2]Simulator* sim, isize id);
void sim_sort_bodies_on_id([1]Simulator* sim);
void sim_remove_body([2]Simulator* sim, isize body);
void sim_remove_body([2]Simulator* sim, Sim_Body* body);
Sim_Body* sim_query_aabb([2]Simulator* sim, AABB query);
int32 _do_collide_bodies([4]Sim_Body* a, Sim_Body* b, Simulator* sim, bool do_sweep);
void _separate_bodies([5]Sim_Body* a, Sim_Body* b, bool capture_contacts, int32 times, Simulator* sim);
void sim_update([4]Simulator* sim, Tilemap* map, real dt, bool capture_contacts true = true),);
Tile_Info* _get_at([2]isize x, isize y);
void generate_statics_for_tilemap([2]Simulator* sim, Tilemap* tilemap);
Particle_Style copy_particle_style([3]Particle_Style s, Vec2 impulse_range, Vec2i time_range);
Particle_Style make_particle_style([17]Rect2 texture, Vec2 size, Vec4 color, Vec4 shadow_color, Vec3 acl, Vec2 impulse_range, Vec2 angle_range, Vec2 angle_vel_range, Vec2 scale_range, Vec2i frame_range, int32 max_frames, int32 framerate, Vec2i time_range, bool time_scaling, real ground_restitution, Vec2 skid_on_bounce_range, real jitter_on_bounce_mag);
void init_particle([9]Particle* p, Vec3 pos, Vec3 vel, real scale, real angle, real anglev, int32 frame, int32 time, int32 style_index);
void init_emitter([3]Emitter* e, isize max_particles, Memory_Arena* arena);
void emitter_spawn([5]Emitter* e, Vec3 pos, Vec2 angle_range, isize count, Particle_Style style);
void emitter_render([3]Emitter* e, Simulator* sim, real dt);
GenerateIntrosortForType([4]_hitbox_sort_on_x_axis, Hitbox, _hitbox_get_x1);
void init_world_area([2]World_Area* area, Memory_Arena* arena);
void init_entity([1]Entity* entity);
Entity* world_area_get_next_entity([1]World_Area* area);
Entity* world_area_find_entity([2]World_Area* area, isize id);
void world_area_sort_entities_on_id([1]World_Area* area);
void world_area_synchronize_entities_and_bodies([1]World_Area* area);
bool world_area_remove_entity([2]World_Area* area, Entity* entity);
void world_area_remove_entity_internal([2]World_Area* area, isize id);
void world_area_process_removed_entities([1]World_Area* area);
void world_area_build_hitboxes([1]World_Area* area);
void world_area_process_hitboxes([1]World_Area* area);
void init_world([5]World* world, isize width, isize height, usize seed, Memory_Arena* arena);
void world_area_init_player([3]World_Area* area, Vec2i tile_pos, bool move_player true =true),);
void world_area_deinit_player([2]World_Area* area, bool move_player true =true),);
World_Area* world_load_area([3]World* world, isize id, Memory_Arena* arena);
void generate_world_area([3]World* world, World_Area* area, World_Area_Stub* stub);
void world_switch_current_area([3]World* world, Area_Link link, Memory_Arena* arena);
void world_start_in_area([3]World* world, World_Area_Stub* area, Memory_Arena* arena);
void world_delete_self([1]World* world);
void generate_world([2]char* name, World* world);
void world_area_walk_entities([2]World_Area* area, World* world);
void world_area_animate_entities([2]World_Area* area, World* world);
bool world_area_frametick_entities([2]World_Area* area, World* world);
void world_area_slowtick_entities([2]World_Area* area, World* world);
void world_area_on_destroy_entity([3]Entity* e, World_Area* area, World* world);
void world_area_on_activate_entity([3]Entity* e, World_Area* area, World* world);
void world_area_hit_entities([2]World_Area* area, World* world);
void world_area_contact_entities([2]World_Area* area, World* world);
void world_area_interact([2]World_Area* area, World* world);
void world_area_render([2]World_Area* area, World* world);
void world_area_update([2]World_Area* area, World* world);
void rituals_prop_drop_on_break([2]World_Area* area, Entity* a);
Entity* rituals_spawn_enemy([3]World_Area* area, isize enemykind, Vec2 position);
void rituals_on_activate_entity([3]Entity* entity, World_Area* area, World* world);
void rituals_on_destroy_entity([3]Entity* e, World_Area* area, World* world);
bool rituals_frametick_entities([4]Entity* entities, isize count, World_Area* area, World* world);
void rituals_slowtick_entities([4]Entity* entities, isize count, World_Area* area, World* world);
void rituals_walk_entities([4]Entity* entities, isize count, World_Area* area, World* world);
void rituals_animate_entities([4]Entity* entities, isize count, World_Area* area, World* world);
void rituals_interact_entities([4]Entity* entities, isize count, World_Area* area, World* world);
void rituals_hit_entities([4]Hitbox_Contact* contacts, isize count, World_Area* area, World* world);
void rituals_entity_on_contact_terrain([3]Entity* e, World_Area* area, World* world);
void rituals_contact_entities([4]Sim_Contact* contacts, isize count, World_Area* area, World* world);
void init_play_state([1]);
void start_play_state([1]char* world_name_in);
void play_state_update([1]);
void play_state_stop([1]);
int delete_file([3]char* path, isize path_length, char* file);
int delete_folder([2]char* path, isize path_length);
int _recursive_delete([3]const char* last_path, isize last_path_len, char* path);
int recursively_delete_folder([2]char* path, bool append_base_path false = false),);
int check_path([1]char* path);
void check_dir([1]char* dir);
void serialize_tile_state([2]Tile_State* state, FILE* file);
void deserialize_tile_state([2]Tile_State* state, FILE* file);
void deserialize_tilemap([3]Tilemap* map, FILE* file, Memory_Arena* arena);
void serialize_tilemap([2]Tilemap* map, FILE* file);
void serialize_sim_body([2]Sim_Body* body, FILE* file);
void deserialize_sim_body([2]Sim_Body* body, FILE* file);
void serialize_simulator([2]Simulator* sim, FILE* file);
void deserialize_simulator([3]Simulator* sim, FILE* file, Memory_Arena* arena);
void serialize_sprite([2]Sprite* s, FILE* file);
void deserialize_sprite([2]Sprite* s, FILE* file);
void deserialize_rituals_entity_userdata([2]Entity* e, FILE* file);
void deserialize_hitbox([2]Hitbox* hb, FILE* file);
void deserialize_entity([2]Entity* entity, FILE* file);
void deserialize_area([3]World_Area* area, FILE* area_file, Memory_Arena* arena);
void serialize_rituals_entity_userdata([2]Entity* e, FILE* file);
void serialize_hitbox([2]Hitbox* hb, FILE* file);
void serialize_entity([2]Entity* entity, FILE* file);
void serialize_area([2]World_Area* area, FILE* area_file);
void serialize_area_link([2]Area_Link* link, FILE* fp);
void deserialize_area_link([3]Area_Link* link, World* world, FILE* fp);
void serialize_world_area_stub([2]World_Area_Stub* stub, FILE* fp);
void deserialize_world_area_stub([3]World_Area_Stub* stub, World* world, FILE* fp);
FILE* get_world_file([2]const char* name, const char* mode);
FILE* get_area_file([3]const char* name, isize id, const char* mode);
void serialize_world([1]World* world);
void deserialize_world([2]World* world, FILE* world_file);
void init_menu_state([1]);
void stop_state([1]);
void start_state([1]);
void switch_state([1]Game_State newstate);
void main_menu_update([1]);
void test_init([1]);
void test_update([1]);
void update([1]);
void load_assets([1]);
void update_screen([1]);
int main([2]int argc, char** argv);
(null)([0]);
